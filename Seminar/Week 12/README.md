<h1>Полиморфна йерархия с рекурсивна дефиниция</h1>

<h3>Какво представлява?</h3>

Това е полиморфна йерархия, в която имаме клас наследник на базовият клас, който съдържа поне един обект от базов клас(може да е и колекция от такива). С други думи получаваме рекурсивна структура, която изглежда нещо подобно на това:

![](https://i.ibb.co/d6Y1rq0/Simple-Task.png)

В случая ще разглеждаме следната структура:

- SimpleTask - проста задача, която има време за изпълнение
- CompositeTask - която се състои от 0 или повече SimpleTask-а.
- CompositeTask е наследник на SimpleTask, което означава, че в CompositeTask можем да имаме други CompositeTask-ове.

<h3>Задача за имплементиране на изчисляване на булеви изрази</h3>

Искаме да реализираме клас за работа с произволни логически изрази. Искаме да имаме функции, за:

- Проверка дали израз е тавтология
- Проверка дали израз е противоречие
- Създаване на такъв израз по символен низ

<h3>Представяне в паметта</h3>

Всеки логически израз е едно от:

- Променлива
- Бинарна операция, която има ляв логически израз и десен логически израз
- Унарна операция, която има друг логически израз

<h3>Пресмятане на стойност на израз</h3>

За да пресметнем стойност на израз ни трябва **булева интерпретация** (оценка на всяка участваща променлива). За това въвеждаме чисто виртуална функция **evaluate**.
Тази функция ще се изпълнява по различен начин от трите вида изрази

- Променливата ще връща оценката от интерпретацията
- Унарната операция ще оцени своя подизраз и спрямо операцията ще върне резултат.
- Бинарната операция ще оцени двата свои подизрази и спрямо операцията ще върне резултат.

! Един логически израз е тавтология, когато за произволна/всяка булева интерпретация той се оценява като истина. !

<h3>Променливите, участващи в логическите изрази</h3>

При построяването на всеки израз ще пазим кои променливи участват. Отново това става по различен начин за трите вида изрази.

- В променливата участва само една променлива (самата тя).
- В унарната операция участват точно тези променливи, които участват в подизраза
- В бинарната операция участват променливите от левия израз и променливите от десния израз (тяхното обединение)

Имайки **променливите и техния брой**, лесно можем да **генерираме всички булеви интерпретации** за тях и да проверим дали израза е **тавтология** или **противоречие**.

<h3>Създаване на такъв израз по символен низ</h3>

За да избегнем въвеждането на приоритет и прилагането на алгоритми като Shunting yard, ще въвеждаме изразите **със скоби около всяка операция**.
Примерен такъв символен низ: (((PvQ)^(TvR))v(!P)).

Как да разберем коя операция се прилага първа? 
- Премахваме първата и последната скоба
- Обхождаме символният низ и използваме брояч. При срещането на отваряща скоба увеличаваме брояча с 1, а при срещането на затваряща - намаляваме броят с 1.
- Символът за операцията, който срещнем когато броячът има стойност 0, е точно операцията, която трябва да се приложи първа. За аргументите на операцията извикваме същата функция рекурсивно.